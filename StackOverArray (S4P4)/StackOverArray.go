package main

import "fmt"

// Определяем структуру Stack, которая представляет стек на основе массива
type Stack struct {
	data []int // Массив, который хранит элементы стека
}

// Создаем метод push для добавления элемента в вершину стека
func (s *Stack) push(data int) {
	// Добавляем элемент в конец массива, который представляет стек
	s.data = append(s.data, data)
}

// Создаем метод pop для удаления элемента из вершины стека и возвращения его данных
func (s *Stack) pop() int {
	// Проверяем, что стек не пуст
	if len(s.data) == 0 {
		fmt.Println("Стек пуст")
		return 0
	}
	// Запоминаем данные последнего элемента массива, который представляет стек
	data := s.data[len(s.data)-1]
	// Удаляем последний элемент массива, уменьшая его длину на единицу
	s.data = s.data[:len(s.data)-1]
	// Возвращаем данные удаленного элемента
	return data
}

// Создаем метод size для определения размера стека
func (s *Stack) size() int {
	// Возвращаем длину массива, который представляет стек
	return len(s.data)
}

// Создаем метод print для вывода элементов стека на экран
func (s *Stack) print() {
	// Выводим элементы массива, который представляет стек, в обратном порядке
	for i := len(s.data) - 1; i >= 0; i-- {
		fmt.Println(s.data[i])
	}
}

func main() {
	// Создаем пустой стек на основе пустого массива
	stack := &Stack{data: []int{}}
	// Добавляем несколько элементов в стек
	stack.push(1)
	stack.push(2)
	stack.push(3)
	stack.push(4)
	stack.push(5)
	// Выводим стек на экран
	fmt.Println("Стек после добавления элементов:")
	stack.print()
	// Удаляем элемент из стека и выводим его данные
	fmt.Println("Удаленный элемент из стека:")
	fmt.Println(stack.pop())
	// Выводим стек на экран
	fmt.Println("Стек после удаления элемента:")
	stack.print()
}
